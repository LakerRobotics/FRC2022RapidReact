package frc.robot.commands;
import com.revrobotics.RelativeEncoder;

import edu.wpi.first.wpilibj.AnalogAccelerometer;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.interfaces.Gyro;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.RobotContainer;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.DriveTrain;
import frc.robot.subsystems.utilities.AdjustSpeedAsTravelHelper;
import frc.robot.subsystems.utilities.AdjustSpeedAsTravelMotionControlHelper;
import frc.robot.subsystems.utilities.EncoderAvgLeftRight;
import frc.robot.subsystems.utilities.EncoderDistenceAsDouble;
import frc.robot.subsystems.utilities.GyroAngleAsDouble;
import frc.robot.subsystems.utilities.MotionControlPIDController;
import frc.robot.subsystems.utilities.PIDOutputDriveTurn;
import frc.robot.subsystems.utilities.PIDOutputStraightMotion;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrainTurnSpinToAngle extends CommandBase {
    private final DriveTrain m_DriveTrain;

    RelativeEncoder m_leftEncoder; 
    RelativeEncoder m_rightEncoder; 
    Gyro m_rotationSource;

	//PIDSource m_TurnSource;
	//DoubleSupplier m_TurnSource;
	private Gyro m_TurnSource;
    private double m_targetAngle;
    
//	private double m_StraightTolerance;
//	private AdjustSpeedAsTravelHelper m_AdustsSpeedAsTravelStraightHelper;
//    private PIDOutputStraightMotion    m_StraightRotationPIDOutput;
//	private MotionControlPIDController m_StraightDistancePIDController;

    private AdjustSpeedAsTravelMotionControlHelper m_AdjustRpmAsTurnHelper;

	private MotionControlPIDController m_TurnPIDController;

    private double m_TurnTolerance = 5;// had been 0.5		
    private double m_AngularVelocityTolerance = 15;

	private final double TurnKp = 0.005;
	private final double TurnKi = 0.0020;
	private final double TurnKd = 0.0;
	private final double TurnMaxPower = 1;
 

/** 
    * @param theDriveTrain the drivetrain subsystem
    * @param turnToAngle In Degrees, in some field reference fram, like lookig downfield is 0 derees
    ------------------------------------------------*/
   public DriveTrainTurnSpinToAngle(DriveTrain theDriveTrain, double turnToAngle){


        m_DriveTrain = theDriveTrain;
        m_TurnSource = theDriveTrain.getGyro();
        m_targetAngle = turnToAngle;
    

    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
	{
        		//TODO to really have it turn on a Dime should monitor left to right wheel and make sure adding them goes to Zero
		// create a forward motion PID control on that then you can get precise turning.
//		if (!m_PIDEnabled)
//		{
//			m_DriveTrain.ResetGyro();
			double start = m_TurnSource.getAngle();
			
			//TODO Magic numbers need fixing
			//TODO What are the units?
			double maxRPM = 60/*30*/;			// Rotations/Minute
			double ramp = 45/* 3.5 * maxRPM*/;	//angle off from target to start slowing down.
			
			double maxSpeed = maxRPM * 6; // 360 Degrees/60 seconds to convert RPM to speed or degrees per second
//			m_targetAngle = turnToAngle;
//			+ start;
			
			if (!(Math.abs(m_TurnSource.getAngle()-m_targetAngle) < m_TurnTolerance))
			{
				
				//Instantiates a new MotionControlHelper() object for the new turn segment
				m_AdjustRpmAsTurnHelper = new AdjustSpeedAsTravelMotionControlHelper(m_targetAngle, ramp, maxSpeed, start, 
				                                                                      new GyroAngleAsDouble(m_TurnSource), 
																					  new PIDOutputDriveTurn(m_DriveTrain));
//DontThinkNeeded				m_TurnControl.setTargetDistance(m_targetAngle);
				
				//Instantiates a new MotionControlPIDController() object for the new turn segment using the previous MotionControlHelper()
				m_TurnPIDController = new MotionControlPIDController(TurnKp, TurnKi, TurnKd, m_AdjustRpmAsTurnHelper);
				//m_TurnPIDController.setOutputRange(-TurnMaxPower, TurnMaxPower);// No longer available would have to code ourselves, they recommoned using a function clamp
				
				//Turns the MotionControlPID ON and it will continue to execute by itself until told otherwise.
				//m_TurnPIDController.enable();	
				//m_PIDEnabled = true;
				
//				return true;
			}
//			return false;

	}

    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        //get 
/*        double distanceSoFar = m_LineSource.getDistance();
        double targetSpeed = m_AdustsSpeedAsTravelStraightHelper.getTargetSpeed(distanceSoFar);
        double currentSpeed = m_LineSource.getRate();
        double forwardPower = m_StraightDistancePIDController.calculate(currentSpeed, targetSpeed);
*/
        double angleRightNow = m_TurnSource.getAngle();
        double targetRotationSpeed = m_AdjustRpmAsTurnHelper.getTargetSpeed(angleRightNow);
        double currentRotationSpeed = m_TurnSource.getRate();
        double turnPower = m_TurnPIDController.calculate(currentRotationSpeed,targetRotationSpeed);

              m_DriveTrain.arcadeDrive(0, turnPower);

//            SmartDashboard.putNumber("DriveStraign Target distance", m_DistanceToExceed);
//            SmartDashboard.putNumber("DriveStraight distanceSoFar", distanceSoFar );
//            SmartDashboard.putNumber("DriveStraight targetSpeed", targetSpeed);
//            SmartDashboard.putNumber("DriveStraight forwardPower", forwardPower);
            SmartDashboard.putNumber("DriveStraight angleRightNow", angleRightNow);
            SmartDashboard.putNumber("DriveStraight turnPower", turnPower);
        }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
            /*
             * Called while waiting for the MotionControlPID to finish. The PID will be disabled when the end condition is met, and
             * the return value indicates you can proceed to the next step.
             * */
            if (Math.abs(m_TurnSource.getAngle()-m_targetAngle) < m_TurnTolerance &&
                Math.abs(m_TurnSource.getRate()               ) < m_AngularVelocityTolerance)
            {
    //OLD TODO: get calulate called and do something with the next output value				m_TurnPIDController.disable();
                //m_DriveTrain.ArcadeDrive(0, 0);
    //OLD TODO: get calulate called and do something with the next output value				m_PIDEnabled = false;
                return true;
            }
            return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
