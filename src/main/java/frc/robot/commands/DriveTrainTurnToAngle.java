package frc.robot.commands;
import com.revrobotics.RelativeEncoder;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.interfaces.Gyro;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.RobotContainer;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import frc.robot.subsystems.DriveTrain;
import frc.robot.subsystems.utilities.AdjustSpeedAsTravelHelper;
import frc.robot.subsystems.utilities.AdjustSpeedAsTravelMotionControlHelper;
import frc.robot.subsystems.utilities.EncoderAvgLeftRight;
import frc.robot.subsystems.utilities.EncoderDistenceAsDouble;
import frc.robot.subsystems.utilities.MotionControlPIDController;
import frc.robot.subsystems.utilities.PIDOutputStraightMotion;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS

/**
 *
 */
public class DriveTrainTurnToAngle extends CommandBase {
    private final DriveTrain m_DriveTrain;

    RelativeEncoder m_leftEncoder; 
    RelativeEncoder m_rightEncoder; 
    Gyro m_rotationSource;

	//PIDSource m_LineSource;
	//DoubleSupplier m_LineSource;
    private Encoder m_LineSource;
	//PIDSource m_TurnSource;
	//DoubleSupplier m_TurnSource;
	private Gyro m_TurnSource;
    private double m_distance;
    private double m_DistanceToExceed; //TODO Check if can Eliminate this redudent variable
    private double m_maxspeed;
    private double m_ramp;
    private double m_targetAngle;
    
	private double m_StraightTolerance;
	private AdjustSpeedAsTravelHelper m_AdustsSpeedAsTravelStraightHelper;
    private PIDOutputStraightMotion    m_StraightRotationPIDOutput;
	private MotionControlPIDController m_StraightDistancePIDController;


    private boolean isStraightMovingForward = true;
    private final double StraightKp = 0.08;
    private final double StraightKi = 0.0001;
    private final double StraightKd = 0.0;
    private final double StraightMaxPower = 1;

 

/** 
    * @param theDriveTrain the drivetrain subsystem
    * @param turnToAngle In Degrees, in some field reference fram, like lookig downfield is 0 derees
    ------------------------------------------------*/
   public DriveTrainTurnToAngle(DriveTrain theDriveTrain, double turnToAngle){


        m_DriveTrain = theDriveTrain;
    

    }

    // Called when the command is initially scheduled.
    @Override
    public void initialize() {
	{
	}

    }

    // Called every time the scheduler runs while the command is scheduled.
    @Override
    public void execute() {
        //get 
/*        double distanceSoFar = m_LineSource.getDistance();
        double targetSpeed = m_AdustsSpeedAsTravelStraightHelper.getTargetSpeed(distanceSoFar);
        double currentSpeed = m_LineSource.getRate();
        double forwardPower = m_StraightDistancePIDController.calculate(currentSpeed, targetSpeed);
*/
        double angleRightNow = m_TurnSource.getAngle();
        double turnPower = m_StraightRotationPIDOutput.calculate(angleRightNow,m_targetAngle);

              m_DriveTrain.arcadeDrive(forwardPower, turnPower);

//            SmartDashboard.putNumber("DriveStraign Target distance", m_DistanceToExceed);
//            SmartDashboard.putNumber("DriveStraight distanceSoFar", distanceSoFar );
//            SmartDashboard.putNumber("DriveStraight targetSpeed", targetSpeed);
//            SmartDashboard.putNumber("DriveStraight forwardPower", forwardPower);
            SmartDashboard.putNumber("DriveStraight angleRightNow", angleRightNow);
            SmartDashboard.putNumber("DriveStraight turnPower", turnPower);
        }

    // Called once the command ends or is interrupted.
    @Override
    public void end(boolean interrupted) {
    }

    // Returns true when the command should end.
    @Override
    public boolean isFinished() {
            /*
             * Called while waiting for the MotionControlPID to finish. The PID will be disabled when the end condition is met, and
             * the return value indicates you can proceed to the next step.
             * */
//            SmartDashboard.putNumber("Distance Left", m_DriveTrain.GetLeftDistance());
            SmartDashboard.putNumber("Target distance", m_DistanceToExceed);
            SmartDashboard.putNumber("Straight Tolerance", m_StraightTolerance);
            
            //TODO Verify this tolerance works... it should...
            SmartDashboard.putNumber("Average Distance", m_LineSource.getDistance());
            SmartDashboard.putNumber("Target", Math.abs(m_DistanceToExceed - m_StraightTolerance));
    
            boolean didExceedDistance = false;
            if(isStraightMovingForward) {
                // Traveling Forward
                if (m_LineSource.getDistance() > m_DistanceToExceed) {
                    didExceedDistance = true;
                }else {
                    didExceedDistance = false;
                }
            }else {
                // Traveling Backward
                if (m_LineSource.getDistance() < m_DistanceToExceed) {
                    didExceedDistance = true;
                }else {
                    didExceedDistance = false;
                }
            }
            if(didExceedDistance){
                if(m_StraightDistancePIDController != null) {
    //OLD TODO: get calulate called and do something with the next output value					m_StraightDistancePIDController.disable();
    //OLD TODO: get calulate called and do something with the next output value					m_StraightRotationPIDOutput.disableRotationPIDController();
                }
    //OLD TODO: get calulate called and do something with the next output value				m_PIDEnabled = false;
                return true;
            }
            return false;
    }

    @Override
    public boolean runsWhenDisabled() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
        return false;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DISABLED
    }
}
